<html>
    <head>
        <title>Canvas revived</title>
    </head>
    <body>
        <input placeholder='username' id='user'>
        <input placeholder='password' id='pass'>
        <button id='signupBtn' onclick='signup(document.getElementById(`user`).value, document.getElementById(`pass`).value, afterSpriteLoaded)'>SIGN UP</button>
        <button id='loginBtn' onclick='login(document.getElementById(`user`).value, document.getElementById(`pass`).value, afterSpriteLoaded)'>LOG IN</button>
        <p id='feedback'></p>
        <canvas id='cvs'></canvas>
        <script src='./blockIds.js'></script>
        <script>
            let ioT = null;
            let socket = null;
            let socketId = null;
            let executedCmdId = [];

            let nextCmdId = 0;
            let unauthCmd = {}; // unauthorised command record: id - cmdName    

            const interactable = [B.TREE, B.TREE1, B.TREE2, B.TREE3];
            const passable = [B.GRASS, B.STUMP];
            
            let lastInput = 0;
            let inputCd = 300;

            let keyMap = {};

            document.body.onload = ()=>{
                loadSpriteMap(afterSpriteLoaded);
            }

            function afterSpriteLoaded() {
                render();
                // initial emit, to be put into channel
                socket = ioT(window.location.href);
                socket.on('connect', ()=>{
                    socketId = socket.id;
                    socket.emit('initiate', session);
                })

                socket.on('test', ()=>{
                    console.log('test signal received');
                })

                socket.on('newMapData', data=>{
                    let d = JSON.parse(data);
                    for (x in d) {
                        overMap[parseInt(x.split(',')[1])][parseInt(x.split(',')[0])] = d[x];
                        fakeOverMap[parseInt(x.split(',')[1])][parseInt(x.split(',')[0])] = d[x];
                    }
                    render();
                })
                
                socket.on('newPlayerData', data=>{
                    let d = JSON.parse(data);
                    for (x in plData) {
                        if (x != plId) delete plData[x];
                    }
                    d.forEach(x=>{
                        if (x.id != plId) {
                            plData[x.id] = x;
                        }
                    })
                    render();
                })

                socket.on('newPlayer', data=>{
                    let d = JSON.parse(data);
                    plData[d.id] = d;
                    render();
                })

                socket.on('authCmd', id=>{
                    authedCmd(id);
                })

                function authedCmd(id) {
                    if (unauthCmd.hasOwnProperty(id)) {
                        fakePl = JSON.parse(JSON.stringify(plData[plId]));
                        fakeOverMap = JSON.parse(JSON.stringify(overMap));
                        simulateCmd(unauthCmd[id]);
                        plData[plId] = fakePl;
                        overMap = fakeOverMap;
                        delete unauthCmd[id];
                        simulateAllUnauth();
                    }
                }

                socket.on('rejectCmd', id=>{
                    console.log('rejectCmd');
                    for (x in unauthCmd) {
                        if (x >= id) {
                            delete unauthCmd[id];
                        }
                    }
                    simulateAllUnauth();
                })

                socket.on('blockChange', (chunk, pos, type) => {
                    overMap[JSON.parse(chunk).y][JSON.parse(chunk).x][JSON.parse(pos).y][JSON.parse(pos).x][JSON.parse(pos).z] = type;
                    fakeOverMap[JSON.parse(chunk).y][JSON.parse(chunk).x][JSON.parse(pos).y][JSON.parse(pos).x][JSON.parse(pos).z] = type;
                    
                    render();
                })

                document.body.addEventListener('keydown', e=>{
                    if ((Date.now() - lastInput) >= 100) {
                        lastInput = Date.now();
                        if (!keyMap[e.key]) {
                            if (Object.keys(keyMap).filter(x=>x!=e.key).length > 0) {
                                return;
                            }
                            keyPressed(e.key);
                            keyMap[e.key] = setInterval(()=>{
                                for (x in keyMap) {
                                    if (keyMap[x]) {
                                        keyPressed(x);
                                    }
                                }
                            }, inputCd);
                        }
                    }
                    // keyPressed(e.key);
                })

                document.body.addEventListener('keyup', e=>{
                    clearInterval(keyMap[e.key]);
                    delete keyMap[e.key];
                })
            }

            function keyPressed(key) {
                let data = fakePl;
                switch (key) {
                    case 'a':
                    case 'd':
                    {
                        let multiplier = key == 'd' ? 1 : -1;
                        // check player not on edge
                        if (((data.chunk.x < (chnx-1) || data.pos.x < (chw-1)) && key == 'd') || ((data.chunk.x > 0 || data.pos.x > 0) && key == 'a')) {
                            // check player not in dest
                            let playerInDest = false;
                            let destChunk = {
                                x: (data.chunk.x + Math.floor((data.pos.x + multiplier)/chw)),
                                y: data.chunk.y
                            }
                            let destPos = {
                                x: (data.pos.x + multiplier + chw)%chw,
                                y: data.pos.y,
                                z: data.z
                            }
                            for (p in plData) {
                                if (p != plId && plData[p].chunk.x == destChunk.x && plData[p].chunk.y == destChunk.y && plData[p].pos.x == destPos.x && plData[p].pos.y == destPos.y && plData[p].z == destPos.z) {
                                    playerInDest = true;
                                }
                            }
                            if (!playerInDest) {
                                if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                    console.log('m2');
                                    let newId = nextCmdId++;
                                    socket.emit('movement', session, key, newId);
                                    unauthCmd[newId] = 'mv' + key.toUpperCase();

                                    simulateAllUnauth();
                                }
                                else {
                                    if (interactable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z])) {
                                        let newId = nextCmdId++;
                                        socket.emit('interact', session, key, newId);
                                        unauthCmd[newId] = `in${key.toUpperCase()}`;

                                        simulateAllUnauth();
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case 's':
                    case 'w':
                    {
                        let multiplier = key == 's' ? 1 : -1;
                        // check player not on edge
                        if (((data.chunk.y < chny-1 || data.pos.y < chh-1) && key == 's') || ((data.chunk.y > 0 || data.pos.y > 0) && key == 'w')) {
                            // check player not in dest
                            let playerInDest = false;
                            let destChunk = {
                                x: data.chunk.x,
                                y: (data.chunk.y + Math.floor((data.pos.y + multiplier)/chh))
                            }
                            let destPos = {
                                x: data.pos.x,
                                y: (data.pos.y + multiplier + chh)%chh,
                                z: data.z
                            }
                            for (p in plData) {
                                if (p != plId && plData[p].chunk.x == destChunk.x && plData[p].chunk.y == destChunk.y && plData[p].pos.x == destPos.x && plData[p].pos.y == destPos.y && plData[p].z == destPos.z) {
                                    playerInDest = true;
                                }
                            }
                            if (!playerInDest) {
                                if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                    let newId = nextCmdId++;
                                    socket.emit('movement', session, key, newId);
                                    unauthCmd[newId] = 'mv' + key.toUpperCase();

                                    simulateAllUnauth();
                                }
                                else {
                                    if (interactable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z])) {
                                        let newId = nextCmdId++;
                                        socket.emit('interact', session, key, newId);
                                        unauthCmd[newId] = `in${key.toUpperCase()}`;

                                        simulateAllUnauth();
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case 'p':
                    {
                        if (fakePl.z < 5) {
                            let newId = nextCmdId++;
                            socket.emit('placeBlock', session, B.WOODWALL, newId);
                            unauthCmd[newId] = `pl${B.WOODWALL}`;

                            simulateAllUnauth();
                        }
                    }
                }
            }

            function simulateCmd(name) {
                switch (name) {
                    case 'mvD':
                        fakePl.pos.x++;
                        if (fakePl.pos.x >= chw) {
                            fakePl.pos.x = 0;
                            fakePl.chunk.x++;
                        }
                        destZ = fakePl.z;
                        destColumn = overMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x].slice(0, fakePl.z).toReversed();
                        // destColumn.reverse();
                        for (let i=0; i<destColumn.length; i++) {
                            if (destColumn[i] !== null) {
                                destZ -= i;
                                break;
                            }
                        }
                        fakePl.z = destZ;
                        render();
                        break;
                    case 'mvA':
                        fakePl.pos.x--;
                        if (fakePl.pos.x < 0) {
                            fakePl.pos.x = chw-1;
                            fakePl.chunk.x--;
                        }
                        destZ = fakePl.z;
                        destColumn = overMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x].slice(0, fakePl.z).toReversed();
                        
                        for (let i=0; i<destColumn.length; i++) {
                            if (destColumn[i] !== null) {
                                destZ -= i;
                                break;
                            }
                        }
                        fakePl.z = destZ;
                        render();
                        break;
                    case 'mvS':
                        fakePl.pos.y++;
                        if (fakePl.pos.y >= chh) {
                            fakePl.pos.y = 0;
                            fakePl.chunk.y++;
                        }
                        destZ = fakePl.z;
                        destColumn = overMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x].slice(0, fakePl.z).toReversed();
                        for (let i=0; i<destColumn.length; i++) {
                            if (destColumn[i] !== null) {
                                destZ -= i;
                                break;
                            }
                        }
                        fakePl.z = destZ;
                        render();
                        break;
                    case 'mvW':
                        fakePl.pos.y--;
                        if (fakePl.pos.y < 0) {
                            fakePl.pos.y = chh-1;
                            fakePl.chunk.y--;
                        }
                        destZ = fakePl.z;
                        destColumn = overMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x].slice(0, fakePl.z).toReversed();
                        for (let i=0; i<destColumn.length; i++) {
                            if (destColumn[i] !== null) {
                                destZ -= i;
                                break;
                            }
                        }
                        fakePl.z = destZ;
                        render();
                        break;
                    case 'inD':
                    case 'inA': {
                        let xMult = name[2] == 'D' ? 1 : -1;
                        let destChunk = {
                            x: (fakePl.chunk.x + Math.floor((fakePl.pos.x + xMult)/chw)),
                            y: fakePl.chunk.y
                        }
                        let destPos = {
                            x: (fakePl.pos.x + xMult + chw)%chw,
                            y: fakePl.pos.y,
                            z: fakePl.z
                        }
                        interact(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z], destChunk, destPos);
                        break;
                    }
                    case 'inS':
                    case 'inW': {
                        let yMult = name[2] == 'S' ? 1 : -1;
                        let destChunk = {
                            x: fakePl.chunk.x,
                            y: (fakePl.chunk.y + Math.floor((fakePl.pos.y + yMult)/chh))
                        }
                        let destPos = {
                            x: fakePl.pos.x,
                            y: (fakePl.pos.y + yMult + chh)%chh,
                            z: fakePl.z
                        }
                        interact(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z], destChunk, destPos);
                        break;
                    }
                    default:
                        if (name.startsWith('pl')) {
                            console.log(name);
                            let blockId = parseInt(name.substr(2));
                            console.log(blockId);
                            fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z] = blockId;
                            fakePl.z++;
                            while (fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z] !== null && fakePl.z < 5) {
                                fakePl.z++;
                            }
                        }
                        break;
                }
            }

            function interact(type, chunk, pos) {
                if (type == B.TREE) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.TREE1;
                }
                else if (type == B.TREE1) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.TREE2;
                }
                else if (type == B.TREE2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.TREE3;
                }
                else if (type == B.TREE3) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.STUMP;
                    addToInventory(I.WOOD);
                }
            }
            
            function addToInventory(itemId) {
                if (fakePl.inv.hasOwnProperty(itemId)) {
                    fakePl.inv[itemId]++;
                }
                else {
                    fakePl.inv[itemId] = 1;
                }
            }

            function simulateAllUnauth() {
                fakePl = JSON.parse(JSON.stringify(plData[plId]));
                fakeOverMap = JSON.parse(JSON.stringify(overMap));
                let ids = Object.keys(unauthCmd).sort((a, b)=>a-b);
                ids.forEach(x=>{
                    simulateCmd(unauthCmd[x]);
                })
                render();
            } 
        </script>
        <script type="module">
            import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";
            ioT = io;
        </script>
        <script src='./render.js'></script>
        <script src='./login.js'></script>
    </body>
</html>