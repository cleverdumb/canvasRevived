<html>
    <head>
        <title>Canvas revived</title>
    </head>
    <body>
        <p>Controls: wasd to move, c to toggle crafting menu, e to equip item when inv item selected</p>
        <input placeholder='username' id='user'>
        <input placeholder='password' id='pass'>
        <button id='signupBtn' onclick='signup(document.getElementById(`user`).value, document.getElementById(`pass`).value, afterSpriteLoaded)'>SIGN UP</button>
        <button id='loginBtn' onclick='login(document.getElementById(`user`).value, document.getElementById(`pass`).value, afterSpriteLoaded)'>LOG IN</button>
        <p id='feedback'></p>
        <canvas id='cvs'></canvas>
        <script src='./blockIds.js'></script>
        <script src='./simulateCmd.js'></script>
        <script>
            let ioT = null;
            let socket = null;
            let socketId = null;
            let executedCmdId = [];

            let nextCmdId = 0;
            let unauthCmd = {}; // unauthorised command record: id - cmdName  
            let randomSeeds = {}; // random seed for each command: id - seed  
            
            let lastInput = 0;
            // let inputCd = 300;

            let keyMap = {};

            function deepCopy(obj) {
                if (Array.isArray(obj)) {
                    var l = obj.length;
                    var r = new Array(l);
                    for (var i = 0; i < l; i++) {
                        r[i] = deepCopy(obj[i]);
                    }
                    return r;
                }
                return obj;
            }

            document.body.onload = ()=>{
                loadSpriteMap(afterSpriteLoaded);
            }

            function afterSpriteLoaded() {
                render();
                // initial emit, to be put into channel
                socket = ioT(window.location.href);
                socket.on('connect', ()=>{
                    socketId = socket.id;
                    socket.emit('initiate', session);
                })

                socket.on('test', ()=>{
                    console.log('test signal received');
                })

                socket.on('newMapData', data=>{
                    let d = JSON.parse(data);
                    for (x in d) {
                        overMap[parseInt(x.split(',')[1])][parseInt(x.split(',')[0])] = d[x];
                        fakeOverMap[parseInt(x.split(',')[1])][parseInt(x.split(',')[0])] = d[x];
                    }
                    render();
                })
                
                socket.on('newPlayerData', data=>{
                    let d = JSON.parse(data);
                    for (x in plData) {
                        if (x != plId) delete plData[x];
                    }
                    d.forEach(x=>{
                        if (x.id != plId) {
                            plData[x.id] = x;
                        }
                    })
                    render();
                })

                socket.on('newNpcData', data=>{
                    let d = JSON.parse(data);
                    console.log(d);
                    npcs = {};
                    d.forEach(x=>{
                        npcs[x.id] = x;
                    })
                    render();
                })

                socket.on('newPlayer', data=>{
                    let d = JSON.parse(data);
                    plData[d.id] = d;
                    render();
                })

                socket.on('fakePlProp', (prop, data)=>{
                    console.log('prop');
                    console.log(prop, data);
                    plData[plId][prop] = data;

                    simulateAllUnauth();
                })

                socket.on('npcDie', id=>{
                    if (npcs.hasOwnProperty(id)) {
                        delete npcs[id];
                    }

                    render();
                })

                socket.on('fakePlAddToInv', itemId => {
                    if (!unstack.includes(itemId)) {
                        if (plData[plId].inv.hasOwnProperty(itemId)) {
                            plData[plId].inv[itemId]++;
                        }
                        else {
                            plData[plId].inv[itemId] = 1;
                        }
                    }
                    else {
                        if (plData[plId].inv.hasOwnProperty(itemId)) {
                            plData[plId].inv[itemId].instance++;
                            plData[plId].inv[itemId].duras.push(dura);
                        }
                        else {
                            plData[plId].inv[itemId] = {
                                instance: 1,
                                duras: [dura]
                            }
                        }
                    }

                    simulateAllUnauth();
                })

                // socket.on('fakePlRemoveFromInv', (item, ins) => {
                //     if (ins === null) {
                //         if (players[plId].inv.hasOwnProperty(item)) {
                //             if (players[plId].inv[item] > 1) {
                //                 players[plId].inv[item]--;
                //             }
                //             else {
                //                 delete players[plId].inv[item];
                //             }
                //         }
                //     }
                // })

                socket.on('npcData', data=>{
                    let d = JSON.parse(data);
                    npcs[d.id] = d;
                    render();
                })

                socket.on('authCmd', id=>{
                    authedCmd(id);
                })

                socket.on('disconnect', ()=>{
                    location.reload();
                })

                function authedCmd(id) {
                    if (unauthCmd.hasOwnProperty(id)) {
                        fakePl = JSON.parse(JSON.stringify(plData[plId]));
                        fakeOverMap = deepCopy(overMap);
                        simulateCmd(unauthCmd[id], id);
                        plData[plId] = fakePl;
                        overMap = fakeOverMap;
                        // copy over to bottom
                        delete unauthCmd[id];
                        simulateAllUnauth();
                    }
                }

                socket.on('rejectCmd', id=>{
                    console.log('rejectCmd');
                    for (x in unauthCmd) {
                        if (x >= id) {
                            delete unauthCmd[id];
                        }
                    }
                    simulateAllUnauth();
                })

                socket.on('blockChange', (chunk, pos, type) => {
                    overMap[JSON.parse(chunk).y][JSON.parse(chunk).x][JSON.parse(pos).y][JSON.parse(pos).x][JSON.parse(pos).z] = type;
                    fakeOverMap[JSON.parse(chunk).y][JSON.parse(chunk).x][JSON.parse(pos).y][JSON.parse(pos).x][JSON.parse(pos).z] = type;
                    
                    render();
                })

                document.body.addEventListener('keydown', e=>{
                    let cd = 300;
                    let clickCd = 100;
                    if ('wasd'.includes(e.key)) {
                        if (fakePl.holding !== null) {
                            let destChunk, destPos;
                            if (e.key == 'a' || e.key == 'd') {
                                let multiplier = e.key == 'a' ? -1 : 1;
                                destChunk = {
                                    x: (fakePl.chunk.x + Math.floor((fakePl.pos.x + multiplier)/chw)),
                                    y: fakePl.chunk.y
                                }
                                destPos = {
                                    x: (fakePl.pos.x + multiplier + chw)%chw,
                                    y: fakePl.pos.y,
                                    z: fakePl.z
                                }
                            }
                            if (e.key == 'w' || e.key == 's') {
                                let multiplier = e.key == 'w' ? -1 : 1;
                                destChunk = {
                                    x: fakePl.chunk.x,
                                    y: (fakePl.chunk.y + Math.floor((fakePl.pos.y + multiplier)/chh))
                                }
                                destPos = {
                                    x: fakePl.pos.x,
                                    y: (fakePl.pos.y + multiplier + chh)%chh,
                                    z: fakePl.z
                                }
                            }

                            let target = overMap[destChunk.y]?.[destChunk.x]?.[destPos.y]?.[destPos.x]?.[destPos.z]

                            if (axe.includes(parseInt(fakePl.holding.id)) || pickaxe.includes(parseInt(fakePl.holding.id))) {
                                if (target !== undefined && requireAxe.includes(target) || requirePickaxe.includes(target)) {
                                    cd = toolCd[parseInt(fakePl.holding.id)];
                                    clickCd = toolCd[parseInt(fakePl.holding.id)];
                                }
                            }
                            else if (sword.includes(parseInt(fakePl.holding.id))) {
                                let npcInDest = false;
                                for (let id in npcs) {
                                    let n = npcs[id]
                                    if (n.chunk.y == destChunk.y && n.chunk.x == destChunk.x && n.pos.y == destPos.y && n.pos.x == destPos.x && destPos.z == 1) {
                                        npcInDest = true;
                                        break;
                                    }
                                }

                                if (npcInDest) {
                                    cd = toolCd[parseInt(fakePl.holding.id)];
                                    clickCd = toolCd[parseInt(fakePl.holding.id)];
                                }
                            }
                        }
                    }
                    if ((Date.now() - lastInput) >= clickCd) {
                        lastInput = Date.now();
                        if (!keyMap[e.key]) {
                            if (Object.keys(keyMap).filter(x=>x!=e.key).length > 0) {
                                return;
                            }
                            keyPressed(e.key);
                            keyMap[e.key] = setInterval(()=>{
                                for (x in keyMap) {
                                    if (keyMap[x]) {
                                        keyPressed(x);
                                    }
                                }
                            }, cd);
                        }
                    }
                    // keyPressed(e.key);
                })

                document.body.addEventListener('keyup', e=>{
                    clearInterval(keyMap[e.key]);
                    delete keyMap[e.key];
                })

                cvs.addEventListener('mousedown', e=>{
                    let x = e.clientX - cvs.getBoundingClientRect().x;
                    let y = e.clientY - cvs.getBoundingClientRect().y;

                    buttons.forEach(b=>{
                        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                            (b.cb)();
                        }
                    })
                })
            }

            function keyPressed(key) {
                let data = fakePl;
                switch (key) {
                    case 'a':
                    case 'd':
                    {
                        let multiplier = key == 'd' ? 1 : -1;
                        // check player not on edge
                        if (((data.chunk.x < (chnx-1) || data.pos.x < (chw-1)) && key == 'd') || ((data.chunk.x > 0 || data.pos.x > 0) && key == 'a')) {
                            // check player not in dest
                            let playerInDest = false;
                            let destChunk = {
                                x: (data.chunk.x + Math.floor((data.pos.x + multiplier)/chw)),
                                y: data.chunk.y
                            }
                            let destPos = {
                                x: (data.pos.x + multiplier + chw)%chw,
                                y: data.pos.y,
                                z: data.z
                            }
                            for (p in plData) {
                                if (p != plId && plData[p].chunk.x == destChunk.x && plData[p].chunk.y == destChunk.y && plData[p].pos.x == destPos.x && plData[p].pos.y == destPos.y && plData[p].z == destPos.z) {
                                    playerInDest = true;
                                }
                            }
                            if (!playerInDest) {
                                if (fakePl.holding === null || !sword.includes(parseInt(fakePl.holding.id))) {
                                    if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                        let newId = nextCmdId++;
                                        socket.emit('movement', session, key, newId);
                                        unauthCmd[newId] = 'mv' + key.toUpperCase();

                                        simulateAllUnauth();
                                    }
                                    else {
                                        let target = fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z];
                                        if (interactable.includes(target)) {
                                            if (requireAxe.includes(target)) {
                                                if (fakePl.holding === null || !axe.includes(parseInt(fakePl.holding.id))) {
                                                    return;
                                                }
                                            }
                                            if (requirePickaxe.includes(target)) {
                                                if (fakePl.holding === null || !pickaxe.includes(parseInt(fakePl.holding.id))) {
                                                    return;
                                                }
                                            }
                                            if (fakePl.inv[fakePl.holding.id].duras[fakePl.holding.ins] >= 1) {
                                                let newId = nextCmdId++;
                                                let seed = Math.round(Math.random() * 1e5);
                                                socket.emit('interact', session, key, newId, seed);
                                                unauthCmd[newId] = `in${key.toUpperCase()}`;
                                                randomSeeds[newId] = seed;

                                                simulateAllUnauth();
                                            }
                                        }
                                    }
                                }
                                else {
                                    let npcInDest = false;
                                    let targetNpc = null;
                                    for (x in npcs) {
                                        let n = npcs[x];
                                        if (n.chunk.x == destChunk.x && n.chunk.y == destChunk.y && n.pos.x == destPos.x && n.pos.y == destPos.y && n.pos.z == destPos.z) {
                                            npcInDest = true;
                                            targetNpc = x;
                                            break;
                                        }
                                    }

                                    if (npcInDest) {
                                        if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                            let newId = nextCmdId++;
                                            socket.emit('movement', session, key, newId, true);
                                            unauthCmd[newId] = 'rot' + key.toUpperCase();

                                            simulateAllUnauth();
                                        }
                                    }
                                    else {
                                        if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                            let newId = nextCmdId++;
                                            socket.emit('movement', session, key, newId);
                                            unauthCmd[newId] = 'mv' + key.toUpperCase();

                                            simulateAllUnauth();
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case 's':
                    case 'w':
                    {
                        let multiplier = key == 's' ? 1 : -1;
                        // check player not on edge
                        if (((data.chunk.y < chny-1 || data.pos.y < chh-1) && key == 's') || ((data.chunk.y > 0 || data.pos.y > 0) && key == 'w')) {
                            // check player not in dest
                            let playerInDest = false;
                            let destChunk = {
                                x: data.chunk.x,
                                y: (data.chunk.y + Math.floor((data.pos.y + multiplier)/chh))
                            }
                            let destPos = {
                                x: data.pos.x,
                                y: (data.pos.y + multiplier + chh)%chh,
                                z: data.z
                            }
                            for (p in plData) {
                                if (p != plId && plData[p].chunk.x == destChunk.x && plData[p].chunk.y == destChunk.y && plData[p].pos.x == destPos.x && plData[p].pos.y == destPos.y && plData[p].z == destPos.z) {
                                    playerInDest = true;
                                }
                            }
                            if (!playerInDest) {
                                if (fakePl.holding === null || !sword.includes(parseInt(fakePl.holding.id))) {
                                    if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                        let newId = nextCmdId++;
                                        socket.emit('movement', session, key, newId);
                                        unauthCmd[newId] = 'mv' + key.toUpperCase();

                                        simulateAllUnauth();
                                    }
                                    else {
                                        let target = fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z];
                                        if (interactable.includes(target)) {
                                            if (requireAxe.includes(target)) {
                                                if (fakePl.holding === null || !axe.includes(parseInt(fakePl.holding.id))) {
                                                    return;
                                                }
                                            }
                                            if (requirePickaxe.includes(target)) {
                                                if (fakePl.holding === null || !pickaxe.includes(parseInt(fakePl.holding.id))) {
                                                    return;
                                                }
                                            }
                                            if (fakePl.inv[fakePl.holding.id].duras[fakePl.holding.ins] >= 1) {
                                                let newId = nextCmdId++;
                                                let seed = Math.round(Math.random() * 1e5);
                                                socket.emit('interact', session, key, newId, seed);
                                                unauthCmd[newId] = `in${key.toUpperCase()}`;
                                                randomSeeds[newId] = seed;

                                                simulateAllUnauth();
                                            }
                                        }
                                    }
                                }
                                else {
                                    let npcInDest = false;
                                    let targetNpc = null;
                                    for (x in npcs) {
                                        let n = npcs[x];
                                        if (n.chunk.x == destChunk.x && n.chunk.y == destChunk.y && n.pos.x == destPos.x && n.pos.y == destPos.y && n.pos.z == destPos.z) {
                                            npcInDest = true;
                                            targetNpc = x;
                                            break;
                                        }
                                    }

                                    if (npcInDest) {
                                        if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                            let newId = nextCmdId++;
                                            socket.emit('movement', session, key, newId, true);
                                            unauthCmd[newId] = 'rot' + key.toUpperCase();

                                            simulateAllUnauth();
                                        }
                                    }
                                    else {
                                        if (fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z] === null || passable.includes(fakeOverMap[destChunk.y][destChunk.x][destPos.y][destPos.x][destPos.z]) || fakePl.z >= 5) {
                                            let newId = nextCmdId++;
                                            socket.emit('movement', session, key, newId);
                                            unauthCmd[newId] = 'mv' + key.toUpperCase();

                                            simulateAllUnauth();
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case 'c':
                        craftMenuOpen = !craftMenuOpen;
                        render();
                        break;
                    case 'e':
                        // check if equipment
                        if (unstack.includes(parseInt(invSel))) {
                            // check if inventory has the item
                            if (invSel !== null && fakePl.inv.hasOwnProperty(invSel) && invSelIns < fakePl.inv[invSel].instances) {
                                // check if it is held-equipment
                                if (axe.includes(parseInt(invSel)) || pickaxe.includes(parseInt(invSel)) || sword.includes(parseInt(invSel)) || parseInt(invSel) == I.BOW) {
                                    // check if it is currently equiped
                                    if (!(fakePl.holding !== null && fakePl.holding.id == invSel && fakePl.holding.ins == invSelIns)) {
                                        let newId = nextCmdId++;
                                        socket.emit('hold', session, parseInt(invSel), parseInt(invSelIns), newId);
                                        unauthCmd[newId] = `ho${invSel}-${invSelIns}`;

                                        simulateAllUnauth();
                                    }
                                    else {
                                        let newId = nextCmdId++;
                                        socket.emit('unhold', session, parseInt(invSel), parseInt(invSelIns), newId);
                                        unauthCmd[newId] = `unho${invSel}-${invSelIns}`;

                                        simulateAllUnauth();
                                    }
                                }
                                else if (armor.includes(parseInt(invSel))) {
                                    if (!(fakePl.armor !== null && fakePl.armor.id == invSel && fakePl.armor.ins == invSelIns)) {
                                        let newId = nextCmdId++;
                                        socket.emit('hold', session, parseInt(invSel), parseInt(invSelIns), newId);
                                        unauthCmd[newId] = `ho${invSel}-${invSelIns}`;

                                        simulateAllUnauth();
                                    }
                                    else {
                                        let newId = nextCmdId++;
                                        socket.emit('unhold', session, parseInt(invSel), parseInt(invSelIns), newId);
                                        unauthCmd[newId] = `unho${invSel}-${invSelIns}`;

                                        simulateAllUnauth();
                                    }
                                }
                                else if (helm.includes(parseInt(invSel))) {
                                    if (!(fakePl.helm !== null && fakePl.helm.id == invSel && fakePl.helm.ins == invSelIns)) {
                                        let newId = nextCmdId++;
                                        socket.emit('hold', session, parseInt(invSel), parseInt(invSelIns), newId);
                                        unauthCmd[newId] = `ho${invSel}-${invSelIns}`;

                                        simulateAllUnauth();
                                    }
                                    else {
                                        let newId = nextCmdId++;
                                        socket.emit('unhold', session, parseInt(invSel), parseInt(invSelIns), newId);
                                        unauthCmd[newId] = `unho${invSel}-${invSelIns}`;

                                        simulateAllUnauth();
                                    }
                                }
                            }
                        }
                        break;
                }
            }

            function shootBow() {
                if ((Date.now() - lastInput) > toolCd[I.BOW]) {
                    if (fakePl.holding !== null && fakePl.holding.id == I.BOW && fakePl.inv[I.BOW].instances > fakePl.holding.ins && fakePl.inv[I.BOW].duras[fakePl.holding.ins] > 0) {
                        if (fakePl.ammo !== null && arrow.includes(fakePl.ammo)) {
                            lastInput = Date.now();

                            let cmdId = nextCmdId++;
                            let seed = Math.round(Math.random()*1e5);
                            randomSeeds[cmdId] = seed;
                            unauthCmd[cmdId] = `shoot`;
                            socket.emit('shootBow', session, cmdId, seed);

                            simulateAllUnauth();
                        }
                    }
                }
            }

            function setAsAmmo() {
                if (arrow.includes(parseInt(invSel))) {
                    let cmdId = nextCmdId++;
                    unauthCmd[cmdId] = `ammo${invSel}`;
                    socket.emit('ammo', session, parseInt(invSel), cmdId);

                    simulateAllUnauth();
                }
            }

            function use(item) {
                if (fakePl.inv.hasOwnProperty(item) && fakePl.inv[item] > 0) {
                    if (placeable.some(x=>I[x] == item)) {
                        let itemName = null;
                        for (let n=0; n<placeable.length; n++) {
                            if (I[placeable[n]] == item) {
                                itemName = placeable[n];
                                break;
                            }
                        }
                        let blockId = B[itemName];
                        if (fakePl.z < 5) {
                            if (fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z] === null) {
                                let newId = nextCmdId++;
                                socket.emit('placeBlock', session, blockId, I[itemName], newId);
                                unauthCmd[newId] = `pl${blockId}`;

                                newId = nextCmdId++;
                                socket.emit('use', session, I[itemName], newId);
                                unauthCmd[newId] = `use${I[itemName]}`;

                                simulateAllUnauth();
                            }
                        }
                    }
                    else {
                        if (usable.includes(item)) {
                            let cmdId = nextCmdId++;
                            socket.emit('use', session, item, cmdId);
                            unauthCmd[cmdId] = `use${item}`;
                        }
                    }
                }
            }

            function craft(type, amount) {
                let cmdId = nextCmdId++;
                socket.emit('craft', session, type, amount, cmdId);
                unauthCmd[cmdId] = `cr${type}-${amount}`;
            }

            function interact(type, chunk, pos, seed) {
                if (requireAxe.includes(type)) {
                    if (fakePl.holding.id != I.WOODAXE) {
                        fakePl.inv[fakePl.holding.id].duras[fakePl.holding.ins]--;
                    }
                }
                if (requirePickaxe.includes(type)) {
                    if (fakePl.holding.id != I.WOODPICK) {
                        fakePl.inv[fakePl.holding.id].duras[fakePl.holding.ins]--;
                    }
                }
                

                if (type == B.TOMATO2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = null;
                    addToInventory(I.TOMATO, null);
                    addToInventory(I.TOMATO, null);
                    addToInventory(I.TOMATOSEED, null);
                }
                else if (type == B.TOMATO3) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = null;
                    for (let x=0; x<6; x++) {
                        addToInventory(I.TOMATO, null);
                    }
                    addToInventory(I.TOMATOSEED, null);
                    addToInventory(I.TOMATOSEED, null);
                }
                else if (type == B.WHEAT2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = null;
                    for (let x=0; x<3; x++) {
                        addToInventory(I.WHEAT, null);
                    }
                }
                else if (type == B.WHEAT3) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = null;
                    for (let x=0; x<9; x++) {
                        addToInventory(I.WHEAT, null);
                    }
                    addToInventory(I.WHEATSEED, null);
                }
                else if (type == B.WHEAT4) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = null;
                    for (let x=0; x<20; x++) {
                        addToInventory(I.WHEAT, null);
                    }
                    addToInventory(I.WHEATSEED, null);
                    addToInventory(I.WHEATSEED, null);
                }
                else if (type == B.CARROT2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = null;
                    for (let x=0; x<6; x++) {
                        addToInventory(I.CARROT, null);
                    }
                    addToInventory(I.CARROTSEED, null);
                    addToInventory(I.CARROTSEED, null);
                }
                else if (type == B.TREE) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.TREE1;
                }
                else if (type == B.TREE1) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.TREE2;
                }
                else if (type == B.TREE2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.TREE3;
                }
                else if (type == B.TREE3) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.STUMP;
                    addToInventory(I.WOOD);
                    if (seed % 2 === 0) {
                        addToInventory(I.APPLE);
                    }
                    if (seed % 3 === 0) {
                        addToInventory(I.TOMATOSEED);
                    }
                }

                else if (type == B.STONE) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.STONE1;
                }
                else if (type == B.STONE1) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.STONE2;
                }
                else if (type == B.STONE2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.STONE3;
                }
                else if (type == B.STONE3) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.STONEBASE;
                    addToInventory(I.STONE);
                }

                else if (type == B.IRON) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.IRON1;
                }
                else if (type == B.IRON1) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.IRON2;
                }
                else if (type == B.IRON2) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.IRON3;
                }
                else if (type == B.IRON3) {
                    fakeOverMap[chunk.y][chunk.x][pos.y][pos.x][pos.z] = B.IRONBASE;
                    addToInventory(I.IRONORE);
                }
            }
            
            function useEffect(id) {
                if (placeable.some(x=>I[x] == id)) return true;
                switch (id) {
                    case I.APPLE:
                        fakePl.hp += 10;
                        fakePl.hp = Math.min(fakePl.maxHp, fakePl.hp);
                        return true;
                    case I.TOMATOSEED:
                        if (fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z - 1] == B.GRASS) {
                            fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z] = B.TOMATO1;
                        }
                        return true;
                    case I.WHEATSEED:
                        if (fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z - 1] == B.GRASS) {
                            fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z] = B.WHEAT1;
                        }
                        return true;
                    case I.CARROTSEED:
                        if (fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z - 1] == B.GRASS) {
                            fakeOverMap[fakePl.chunk.y][fakePl.chunk.x][fakePl.pos.y][fakePl.pos.x][fakePl.z] = B.CARROT1;
                        }
                        return true;
                    case I.BOW:
                        return false;
                }
            }

            function addToInventory(itemId, dura) {
                if (!unstack.includes(itemId)) {
                    if (fakePl.inv.hasOwnProperty(itemId)) {
                        fakePl.inv[itemId]++;
                    }
                    else {
                        fakePl.inv[itemId] = 1;
                    }
                }
                else {
                    if (fakePl.inv.hasOwnProperty(itemId)) {
                        fakePl.inv[itemId].instance++;
                        fakePl.inv[itemId].duras.push(dura);
                    }
                    else {
                        fakePl.inv[itemId] = {
                            instance: 1,
                            duras: [dura]
                        }
                    }
                }
            }

            function removeFromInv(item, ins) {
                if (ins === null) {
                    if (fakePl.inv.hasOwnProperty(item)) {
                        if (fakePl.inv[item] > 1) {
                            fakePl.inv[item]--;
                        }
                        else {
                            delete fakePl.inv[item];
                        }
                    }
                }
            }

            function simulateAllUnauth() {
                fakePl = JSON.parse(JSON.stringify(plData[plId]));
                fakeOverMap = deepCopy(overMap);
                let ids = Object.keys(unauthCmd).sort((a, b)=>a-b);
                ids.forEach(x=>{
                    simulateCmd(unauthCmd[x], x);
                })
                render();
            } 
        </script>
        <script type="module">
            import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";
            ioT = io;
        </script>
        <script src='./render.js'></script>
        <script src='./login.js'></script>
    </body>
</html>